<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pcilib: lock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">pcilib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0b5c8f32f3013e7b96dc99509907414c.html">pcilib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lock.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>this file is the header file for the functions that implement a semaphore API for the pcitool program, using pthread robust mutexes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="pcilib_8h_source.html">pcilib.h</a>&gt;</code><br />
</div>
<p><a href="lock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a54d0a1249c3ee45d95ccbe09970b7aea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a54d0a1249c3ee45d95ccbe09970b7aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of one lock.  <a href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">More...</a><br /></td></tr>
<tr class="separator:a54d0a1249c3ee45d95ccbe09970b7aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a657bc5577cf8315f3407e29505da135b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpcilib__lock__s.html">pcilib_lock_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a></td></tr>
<tr class="memdesc:a657bc5577cf8315f3407e29505da135b"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure defining a lock  <a href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">More...</a><br /></td></tr>
<tr class="separator:a657bc5577cf8315f3407e29505da135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aac523db17d247c418fb56dbc279113d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> { <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a> = 0
, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a> = 1
, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a> = 2
 }</td></tr>
<tr class="memdesc:aac523db17d247c418fb56dbc279113d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">type that defines possible flags for a lock, defining how a lock should be handled by the locking functions  <a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">More...</a><br /></td></tr>
<tr class="separator:aac523db17d247c418fb56dbc279113d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51fc3ca69c4c13c92fea15a4693471c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a51fc3ca69c4c13c92fea15a4693471c4">pcilib_init_lock</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> flags, const char *lock_id)</td></tr>
<tr class="memdesc:a51fc3ca69c4c13c92fea15a4693471c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function initializes a lock, by setting correctly its property given the flags associated.  <a href="lock_8h.html#a51fc3ca69c4c13c92fea15a4693471c4">More...</a><br /></td></tr>
<tr class="separator:a51fc3ca69c4c13c92fea15a4693471c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995b60d9bd69b6a3bace04a1c2d9b897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a995b60d9bd69b6a3bace04a1c2d9b897">pcilib_free_lock</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock_ctx)</td></tr>
<tr class="memdesc:a995b60d9bd69b6a3bace04a1c2d9b897"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will unref the defined lock.  <a href="lock_8h.html#a995b60d9bd69b6a3bace04a1c2d9b897">More...</a><br /></td></tr>
<tr class="separator:a995b60d9bd69b6a3bace04a1c2d9b897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d31635f64d5b83e3a811dc1b2ddee"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:aab2d31635f64d5b83e3a811dc1b2ddee"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gives the identifier name associated to a lock in the kernel space  <a href="lock_8h.html#aab2d31635f64d5b83e3a811dc1b2ddee">More...</a><br /></td></tr>
<tr class="separator:aab2d31635f64d5b83e3a811dc1b2ddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458f1a70f478cb82cbb5d5586d130bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a458f1a70f478cb82cbb5d5586d130bd8">pcilib_lock_ref</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a458f1a70f478cb82cbb5d5586d130bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment reference count(number of processes that may access the given lock).  <a href="lock_8h.html#a458f1a70f478cb82cbb5d5586d130bd8">More...</a><br /></td></tr>
<tr class="separator:a458f1a70f478cb82cbb5d5586d130bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610ccde435fcf312a7ad21288179966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#aa610ccde435fcf312a7ad21288179966">pcilib_lock_unref</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:aa610ccde435fcf312a7ad21288179966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement reference count (number of processes that may access the given lock) Not thread/process safe unless system supports stdatomic (gcc 4.9+).  <a href="lock_8h.html#aa610ccde435fcf312a7ad21288179966">More...</a><br /></td></tr>
<tr class="separator:aa610ccde435fcf312a7ad21288179966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c22d0774145829eab7f508af1c8268"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#af9c22d0774145829eab7f508af1c8268">pcilib_lock_get_refs</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:af9c22d0774145829eab7f508af1c8268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>approximate</em> number of lock references as the crashed applications will may not unref.  <a href="lock_8h.html#af9c22d0774145829eab7f508af1c8268">More...</a><br /></td></tr>
<tr class="separator:af9c22d0774145829eab7f508af1c8268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ac119e9c186913d1cced9db262d784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a37ac119e9c186913d1cced9db262d784">pcilib_lock_get_flags</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a37ac119e9c186913d1cced9db262d784"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the flags associated to the given lock  <a href="lock_8h.html#a37ac119e9c186913d1cced9db262d784">More...</a><br /></td></tr>
<tr class="separator:a37ac119e9c186913d1cced9db262d784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bb35dfe3a00a051c7cd5ddb91b0b1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> flags, <a class="el" href="pcilib_8h.html#a1d84306119429755a7bfd73b953c01dc">pcilib_timeout_t</a> timeout)</td></tr>
<tr class="memdesc:a14bb35dfe3a00a051c7cd5ddb91b0b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will call different locking functions to acquire the given lock.  <a href="lock_8h.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">More...</a><br /></td></tr>
<tr class="separator:a14bb35dfe3a00a051c7cd5ddb91b0b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75727162630a3ad5cd76822f9f3e41a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a75727162630a3ad5cd76822f9f3e41a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to acquire a lock, and wait till the lock can be acquire  <a href="lock_8h.html#a75727162630a3ad5cd76822f9f3e41a4">More...</a><br /></td></tr>
<tr class="separator:a75727162630a3ad5cd76822f9f3e41a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede6140571a9d717300d31e0fd8079ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#aede6140571a9d717300d31e0fd8079ee">pcilib_try_lock</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:aede6140571a9d717300d31e0fd8079ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will try to take a lock for the mutex pointed by lockfunction to acquire a lock, but that returns immediatly if the lock can't be acquired on first try  <a href="lock_8h.html#aede6140571a9d717300d31e0fd8079ee">More...</a><br /></td></tr>
<tr class="separator:aede6140571a9d717300d31e0fd8079ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770c0ece9679b9b2589bd773b8cfb70e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock_8h.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a> (<a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:a770c0ece9679b9b2589bd773b8cfb70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function unlocks the lock pointed by lock  <a href="lock_8h.html#a770c0ece9679b9b2589bd773b8cfb70e">More...</a><br /></td></tr>
<tr class="separator:a770c0ece9679b9b2589bd773b8cfb70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >this file is the header file for the functions that implement a semaphore API for the pcitool program, using pthread robust mutexes. </p>
<p >the use of pthread robust mutexes was chosen due to the fact we privilege security over fastness, and that pthread mutexes permits to recover semaphores even with crash ,and that it does not require access to resources that can be easily accessible from extern usage as flock file locking mechanism. A possible other locking mechanism could be the sysv semaphores, but we have a problem of how determine a perfect hash for the init function, and more, benchmarks proves that sysv semaphore aren't that stable. For pure locking/unlocking, pthread is better in performance than sysV, but it suffers from big initialization times. In this sense, a kernel memory space is used for saving the locks, and persistence permits to avoid initializations over uses.</p>
<p >We considered that mutex implmentation is enough compared to a reader/writer implementation. If it should change, please go to sysv semaphore.</p>
<p >Basic explanation on how semaphores here work: a semaphore here is a positive integer, thus that can't go below zero, which is initiated with a value. when a process want access to the critical resource, it asks to decrement the value of the semaphore, and when it has finished, it reincrements it.basically, when the semaphore is equal to zero, any process must have to wait for it to be reincremented before decrementing it again. Here are defined two types of access to the semaphore corresponding to the reader/writer problem : an exclusive lock, which means that no other process than the one who have the resource can access it; a shared lock, which means that other processes who want to access to the resource with a shared lock can have the access, but a concurrent process who want to access the semaphore with an exclusive lock won't be able to. explanation on locks here : here locks are registered in kernel memory, where they are defined by a pthread_mutex_t and an identifier name, which corresponds most of the time to a mix of the register associated name and processus (but it's up to the user). The iterations like searching a lock are done on this id name. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a54d0a1249c3ee45d95ccbe09970b7aea" name="a54d0a1249c3ee45d95ccbe09970b7aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d0a1249c3ee45d95ccbe09970b7aea">&#9670;&#160;</a></span>PCILIB_LOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCILIB_LOCK_SIZE&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size of one lock. </p>
<p >indeed, as we can't allocate easily on the fly memory in the kernel, fixed size have been chosen. determines so the size of the identifier name in the way locks are registered. 40 bytes are necessary for the mutex structure, so we have an id name of length LOCK_SIZE-40 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a657bc5577cf8315f3407e29505da135b" name="a657bc5577cf8315f3407e29505da135b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657bc5577cf8315f3407e29505da135b">&#9670;&#160;</a></span>pcilib_lock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpcilib__lock__s.html">pcilib_lock_s</a> <a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure defining a lock </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aac523db17d247c418fb56dbc279113d0" name="aac523db17d247c418fb56dbc279113d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac523db17d247c418fb56dbc279113d0">&#9670;&#160;</a></span>pcilib_lock_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type that defines possible flags for a lock, defining how a lock should be handled by the locking functions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe" name="aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe"></a>PCILIB_LOCK_FLAGS_DEFAULT&#160;</td><td class="fielddoc"><p >Default flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626" name="aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626"></a>PCILIB_LOCK_FLAG_UNLOCKED&#160;</td><td class="fielddoc"><p >Perform operations unlocked, thus without taking care of the lock (protected by global flock during initialization of locking subsystem) </p>
</td></tr>
<tr><td class="fieldname"><a id="aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9" name="aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9"></a>PCILIB_LOCK_FLAG_PERSISTENT&#160;</td><td class="fielddoc"><p >Do not create robust mutexes, but preserve the lock across application launches. </p>
</td></tr>
</table>
<div class="fragment"><div class="line"><span class="lineno">   22</span>             {</div>
<div class="line"><span class="lineno">   23</span>    <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a> = 0,      </div>
<div class="line"><span class="lineno">   24</span>    <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a> = 1,      </div>
<div class="line"><span class="lineno">   25</span>    <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a> = 2     </div>
<div class="line"><span class="lineno">   26</span>} <a class="code hl_enumeration" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>;</div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a></div><div class="ttdeci">pcilib_lock_flags_t</div><div class="ttdoc">type that defines possible flags for a lock, defining how a lock should be handled by the locking fun...</div><div class="ttdef"><b>Definition:</b> lock.h:22</div></div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAG_UNLOCKED</div><div class="ttdoc">Perform operations unlocked, thus without taking care of the lock (protected by global flock during i...</div><div class="ttdef"><b>Definition:</b> lock.h:24</div></div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAGS_DEFAULT</div><div class="ttdoc">Default flags.</div><div class="ttdef"><b>Definition:</b> lock.h:23</div></div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAG_PERSISTENT</div><div class="ttdoc">Do not create robust mutexes, but preserve the lock across application launches.</div><div class="ttdef"><b>Definition:</b> lock.h:25</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a995b60d9bd69b6a3bace04a1c2d9b897" name="a995b60d9bd69b6a3bace04a1c2d9b897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b60d9bd69b6a3bace04a1c2d9b897">&#9670;&#160;</a></span>pcilib_free_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_free_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function will unref the defined lock. </p>
<p >Any subsequent tries to lock it without reinitializaing it will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock_ctx</td><td>- the pointer that points to the lock. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   82</span>                                           {</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">   84</span> </div>
<div class="line"><span class="lineno">   85</span>    assert(lock);</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span><span class="comment">//    if (lock-&gt;refs)</span></div>
<div class="line"><span class="lineno">   88</span><span class="comment">//      pcilib_error(&quot;Forbidding to destroy the referenced mutex...&quot;);</span></div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">if</span> ((err = pthread_mutex_destroy(&amp;lock-&gt;mutex))==-1)</div>
<div class="line"><span class="lineno">   91</span>        <a class="code hl_define" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>(<span class="stringliteral">&quot;Can&#39;t destroy POSIX mutex, errno %i&quot;</span>,errno);</div>
<div class="line"><span class="lineno">   92</span>}</div>
<div class="ttc" id="aerror_8h_html_a62fff84bc7941d1a39700b931716bbe9"><div class="ttname"><a href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a></div><div class="ttdeci">#define pcilib_warning(...)</div><div class="ttdef"><b>Definition:</b> error.h:69</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">pcilib_lock_s::mutex</a>, and <a class="el" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>.</p>

</div>
</div>
<a id="a51fc3ca69c4c13c92fea15a4693471c4" name="a51fc3ca69c4c13c92fea15a4693471c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fc3ca69c4c13c92fea15a4693471c4">&#9670;&#160;</a></span>pcilib_init_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_init_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lock_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function initializes a lock, by setting correctly its property given the flags associated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>- pointer to lock to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- flags: if it's set to two, then not a robust mutex is created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_id</td><td>- lock identificator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or 0 on success </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   36</span>                                                                                          {</div>
<div class="line"><span class="lineno">   37</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">   38</span>    pthread_mutexattr_t attr;</div>
<div class="line"><span class="lineno">   39</span> </div>
<div class="line"><span class="lineno">   40</span>    assert(lock);</div>
<div class="line"><span class="lineno">   41</span>    assert(lock_id);</div>
<div class="line"><span class="lineno">   42</span> </div>
<div class="line"><span class="lineno">   43</span>    memset(lock, 0, <a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>);</div>
<div class="line"><span class="lineno">   44</span> </div>
<div class="line"><span class="lineno">   45</span>    <span class="keywordflow">if</span> (strlen(lock_id) &gt;= (<a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a> - offsetof(<span class="keyword">struct</span> <a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_s</a>, name))) {</div>
<div class="line"><span class="lineno">   46</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;The supplied lock id (%s) is too long...&quot;</span>, lock_id);</div>
<div class="line"><span class="lineno">   47</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f">PCILIB_ERROR_INVALID_ARGUMENT</a>;</div>
<div class="line"><span class="lineno">   48</span>    }</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">if</span> ((err = pthread_mutexattr_init(&amp;attr))!=0) {</div>
<div class="line"><span class="lineno">   51</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t initialize mutex attribute, errno %i&quot;</span>, errno);</div>
<div class="line"><span class="lineno">   52</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   53</span>    }</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>        <span class="comment">/* we declare the mutex as possibly shared amongst different processes*/</span></div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">if</span> ((err = pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED))!=0) {</div>
<div class="line"><span class="lineno">   57</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t configure a shared mutex attribute, errno %i&quot;</span>, errno);</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   59</span>    }</div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span>        <span class="comment">/* we set the mutex as robust, so it would be automatically unlocked if the application crash*/</span></div>
<div class="line"><span class="lineno">   62</span>    <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>)==0) {</div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordflow">if</span> ((err = pthread_mutexattr_setrobust(&amp;attr, PTHREAD_MUTEX_ROBUST))!=0) {</div>
<div class="line"><span class="lineno">   64</span>            <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t configure a robust mutex attribute, errno: %i&quot;</span>, errno);</div>
<div class="line"><span class="lineno">   65</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   66</span>        }</div>
<div class="line"><span class="lineno">   67</span>    }</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordflow">if</span> ((err = pthread_mutex_init(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>, &amp;attr))!=0) {</div>
<div class="line"><span class="lineno">   70</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t create mutex, errno : %i&quot;</span>,errno);</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   72</span>    }</div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span>    strcpy(lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">name</a>, lock_id);</div>
<div class="line"><span class="lineno">   75</span>    lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a> = 1;</div>
<div class="line"><span class="lineno">   76</span>    lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a4a76cb7ff704e8ab9403c9f0362a8bce">flags</a> = flags;</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">   79</span>}</div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f">PCILIB_ERROR_INVALID_ARGUMENT</a></div><div class="ttdeci">@ PCILIB_ERROR_INVALID_ARGUMENT</div><div class="ttdef"><b>Definition:</b> error.h:20</div></div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a></div><div class="ttdeci">@ PCILIB_ERROR_FAILED</div><div class="ttdef"><b>Definition:</b> error.h:22</div></div>
<div class="ttc" id="aerror_8h_html_a2b06064fecffd095efabb752f7b50021"><div class="ttname"><a href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a></div><div class="ttdeci">#define pcilib_error(...)</div><div class="ttdef"><b>Definition:</b> error.h:68</div></div>
<div class="ttc" id="alock_8h_html_a54d0a1249c3ee45d95ccbe09970b7aea"><div class="ttname"><a href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a></div><div class="ttdeci">#define PCILIB_LOCK_SIZE</div><div class="ttdoc">size of one lock.</div><div class="ttdef"><b>Definition:</b> lock.h:15</div></div>
<div class="ttc" id="astructpcilib__lock__s_html"><div class="ttname"><a href="structpcilib__lock__s.html">pcilib_lock_s</a></div><div class="ttdoc">structure to define a lock</div><div class="ttdef"><b>Definition:</b> lock.c:24</div></div>
<div class="ttc" id="astructpcilib__lock__s_html_a1348e822fe29d2958cb5d74d79b064e9"><div class="ttname"><a href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">pcilib_lock_s::name</a></div><div class="ttdeci">char name[]</div><div class="ttdoc">lock identifier</div><div class="ttdef"><b>Definition:</b> lock.c:32</div></div>
<div class="ttc" id="astructpcilib__lock__s_html_a4a76cb7ff704e8ab9403c9f0362a8bce"><div class="ttname"><a href="structpcilib__lock__s.html#a4a76cb7ff704e8ab9403c9f0362a8bce">pcilib_lock_s::flags</a></div><div class="ttdeci">pcilib_lock_flags_t flags</div><div class="ttdoc">flags to define the type of the mutex</div><div class="ttdef"><b>Definition:</b> lock.c:26</div></div>
<div class="ttc" id="astructpcilib__lock__s_html_abc308dc2d6d2ca8c36ff851ee4d316b3"><div class="ttname"><a href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">pcilib_lock_s::refs</a></div><div class="ttdeci">volatile uint32_t refs</div><div class="ttdoc">approximate number of processes that hold the lock initialized, may desynchronize on crashes</div><div class="ttdef"><b>Definition:</b> lock.c:30</div></div>
<div class="ttc" id="astructpcilib__lock__s_html_afd46dde3b2597ff411af6769c38c0a07"><div class="ttname"><a href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">pcilib_lock_s::mutex</a></div><div class="ttdeci">pthread_mutex_t mutex</div><div class="ttdoc">the pthread robust mutex</div><div class="ttdef"><b>Definition:</b> lock.c:25</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#a4a76cb7ff704e8ab9403c9f0362a8bce">pcilib_lock_s::flags</a>, <a class="el" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">pcilib_lock_s::mutex</a>, <a class="el" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">pcilib_lock_s::name</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f">PCILIB_ERROR_INVALID_ARGUMENT</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>, <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>, and <a class="el" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">pcilib_lock_s::refs</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>.</p>

</div>
</div>
<a id="a75727162630a3ad5cd76822f9f3e41a4" name="a75727162630a3ad5cd76822f9f3e41a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75727162630a3ad5cd76822f9f3e41a4">&#9670;&#160;</a></span>pcilib_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to acquire a lock, and wait till the lock can be acquire </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- the pointer to the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or 0 for correctness </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  189</span>                                     {</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="lock_8c.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom</a>(lock, <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, <a class="code hl_define" href="pcilib_8h.html#a01c9c2fd95e634fde53208e3d27ccd84">PCILIB_TIMEOUT_INFINITE</a>);</div>
<div class="line"><span class="lineno">  191</span>}</div>
<div class="ttc" id="alock_8c_html_a14bb35dfe3a00a051c7cd5ddb91b0b1b"><div class="ttname"><a href="lock_8c.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom</a></div><div class="ttdeci">int pcilib_lock_custom(pcilib_lock_t *lock, pcilib_lock_flags_t flags, pcilib_timeout_t timeout)</div><div class="ttdoc">this function will call different locking functions to acquire the given lock.</div><div class="ttdef"><b>Definition:</b> lock.c:135</div></div>
<div class="ttc" id="apcilib_8h_html_a01c9c2fd95e634fde53208e3d27ccd84"><div class="ttname"><a href="pcilib_8h.html#a01c9c2fd95e634fde53208e3d27ccd84">PCILIB_TIMEOUT_INFINITE</a></div><div class="ttdeci">#define PCILIB_TIMEOUT_INFINITE</div><div class="ttdef"><b>Definition:</b> pcilib.h:200</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="lock_8c.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom()</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, and <a class="el" href="pcilib_8h.html#a01c9c2fd95e634fde53208e3d27ccd84">PCILIB_TIMEOUT_INFINITE</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>, and <a class="el" href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock()</a>.</p>

</div>
</div>
<a id="a14bb35dfe3a00a051c7cd5ddb91b0b1b" name="a14bb35dfe3a00a051c7cd5ddb91b0b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bb35dfe3a00a051c7cd5ddb91b0b1b">&#9670;&#160;</a></span>pcilib_lock_custom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_lock_custom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pcilib_8h.html#a1d84306119429755a7bfd73b953c01dc">pcilib_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function will call different locking functions to acquire the given lock. </p>
<p >Given the flags, it is thus possible to: 1) the process requesting the lock will be held till it can acquire it 2)the lock is tried to be acquired, if the lock can be acquired then it is, if not, then the function returns immediatly and the lock is not taken at all 3) same than previous, but it's possible to define a waiting time to acquire the lock before returning</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- the pointer to the mutex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- define the type of lock wanted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>- the waiting time if asked, before the function returns without having obtained the lock, in micro seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or 0 for correctness </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  135</span>                                                                                                 {</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>    <span class="keywordflow">if</span> (!lock) {</div>
<div class="line"><span class="lineno">  139</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;The null lock pointer is passed to lock function&quot;</span>);</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f">PCILIB_ERROR_INVALID_ARGUMENT</a>;</div>
<div class="line"><span class="lineno">  141</span>    }</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structtimespec.html">timespec</a> tm;</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">switch</span> (timeout) {</div>
<div class="line"><span class="lineno">  146</span>     <span class="keywordflow">case</span> <a class="code hl_define" href="pcilib_8h.html#a01c9c2fd95e634fde53208e3d27ccd84">PCILIB_TIMEOUT_INFINITE</a>:</div>
<div class="line"><span class="lineno">  147</span>        <span class="comment">/* the process will be hold till it can gain acquire the lock*/</span></div>
<div class="line"><span class="lineno">  148</span>        err = pthread_mutex_lock(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>);</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  150</span>     <span class="keywordflow">case</span> <a class="code hl_define" href="pcilib_8h.html#a166dd3b3c2d265ec0c88cf5ed001b511">PCILIB_TIMEOUT_IMMEDIATE</a>:</div>
<div class="line"><span class="lineno">  151</span>        <span class="comment">/* the function returns immediatly if it can&#39;t acquire the lock*/</span></div>
<div class="line"><span class="lineno">  152</span>        err = pthread_mutex_trylock(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>);</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  154</span>     <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  155</span>        <span class="comment">/* the process will be hold till it can acquire the lock and timeout is not reached*/</span></div>
<div class="line"><span class="lineno">  156</span>        clock_gettime(CLOCK_REALTIME, &amp;tm);</div>
<div class="line"><span class="lineno">  157</span>        tm.tv_nsec += 1000 * (timeout%1000000);</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">if</span> (tm.tv_nsec &lt; 1000000000)</div>
<div class="line"><span class="lineno">  159</span>            tm.tv_sec += timeout/1000000;</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  161</span>            tm.tv_sec += 1 + timeout/1000000;</div>
<div class="line"><span class="lineno">  162</span>            tm.tv_nsec -= 1000000000;</div>
<div class="line"><span class="lineno">  163</span>        } </div>
<div class="line"><span class="lineno">  164</span>        err = pthread_mutex_timedlock(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>, &amp;tm);</div>
<div class="line"><span class="lineno">  165</span>    }</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>    <span class="keywordflow">if</span> (!err)</div>
<div class="line"><span class="lineno">  168</span>        <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">switch</span> (err) {</div>
<div class="line"><span class="lineno">  171</span>     <span class="keywordflow">case</span> EOWNERDEAD:</div>
<div class="line"><span class="lineno">  172</span>        <span class="comment">/*in the case an application with a lock acquired crashes, this lock becomes inconsistent. we have so to make it consistent again to use it again.*/</span></div>
<div class="line"><span class="lineno">  173</span>        err = pthread_mutex_consistent(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>);</div>
<div class="line"><span class="lineno">  174</span>        <span class="keywordflow">if</span> (err) {</div>
<div class="line"><span class="lineno">  175</span>            <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Failed to mark mutex as consistent, errno %i&quot;</span>, err);</div>
<div class="line"><span class="lineno">  176</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  177</span>        }</div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  179</span>     <span class="keywordflow">case</span> ETIMEDOUT:</div>
<div class="line"><span class="lineno">  180</span>     <span class="keywordflow">case</span> EBUSY:</div>
<div class="line"><span class="lineno">  181</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca827d3ff095354b8776d2274c82e70536">PCILIB_ERROR_TIMEOUT</a>;</div>
<div class="line"><span class="lineno">  182</span>     <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  183</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Failed to obtain mutex, errno %i&quot;</span>, err);</div>
<div class="line"><span class="lineno">  184</span>    }</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">  187</span>}</div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60ca827d3ff095354b8776d2274c82e70536"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca827d3ff095354b8776d2274c82e70536">PCILIB_ERROR_TIMEOUT</a></div><div class="ttdeci">@ PCILIB_ERROR_TIMEOUT</div><div class="ttdef"><b>Definition:</b> error.h:21</div></div>
<div class="ttc" id="apcilib_8h_html_a166dd3b3c2d265ec0c88cf5ed001b511"><div class="ttname"><a href="pcilib_8h.html#a166dd3b3c2d265ec0c88cf5ed001b511">PCILIB_TIMEOUT_IMMEDIATE</a></div><div class="ttdeci">#define PCILIB_TIMEOUT_IMMEDIATE</div><div class="ttdef"><b>Definition:</b> pcilib.h:201</div></div>
<div class="ttc" id="astructtimespec_html"><div class="ttname"><a href="structtimespec.html">timespec</a></div><div class="ttdef"><b>Definition:</b> event.c:33</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">pcilib_lock_s::mutex</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca1d5267b325c591675a462cefbb1d0f7f">PCILIB_ERROR_INVALID_ARGUMENT</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca827d3ff095354b8776d2274c82e70536">PCILIB_ERROR_TIMEOUT</a>, <a class="el" href="pcilib_8h.html#a166dd3b3c2d265ec0c88cf5ed001b511">PCILIB_TIMEOUT_IMMEDIATE</a>, <a class="el" href="pcilib_8h.html#a01c9c2fd95e634fde53208e3d27ccd84">PCILIB_TIMEOUT_INFINITE</a>, <a class="el" href="structtimespec.html#ae3c7510dafa8cbcaede866ed13c99683">timespec::tv_nsec</a>, and <a class="el" href="structtimespec.html#afc3302668d7cb5952f590da69fdd4955">timespec::tv_sec</a>.</p>

<p class="reference">Referenced by <a class="el" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock()</a>, and <a class="el" href="lock_8c.html#aede6140571a9d717300d31e0fd8079ee">pcilib_try_lock()</a>.</p>

</div>
</div>
<a id="a37ac119e9c186913d1cced9db262d784" name="a37ac119e9c186913d1cced9db262d784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ac119e9c186913d1cced9db262d784">&#9670;&#160;</a></span>pcilib_lock_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> pcilib_lock_get_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the flags associated to the given lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- the lock we want to know the flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the flag associated </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  124</span>                                                               {</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">return</span> lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a4a76cb7ff704e8ab9403c9f0362a8bce">flags</a>;</div>
<div class="line"><span class="lineno">  126</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#a4a76cb7ff704e8ab9403c9f0362a8bce">pcilib_lock_s::flags</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>.</p>

</div>
</div>
<a id="aab2d31635f64d5b83e3a811dc1b2ddee" name="aab2d31635f64d5b83e3a811dc1b2ddee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2d31635f64d5b83e3a811dc1b2ddee">&#9670;&#160;</a></span>pcilib_lock_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pcilib_lock_get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gives the identifier name associated to a lock in the kernel space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- pointer to the lock we want the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string corresponding to the name </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  128</span>                                                      {</div>
<div class="line"><span class="lineno">  129</span>    assert(lock);</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">if</span> (lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">name</a>[0]) <span class="keywordflow">return</span> lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">name</a>;</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  133</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">pcilib_lock_s::name</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>, and <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>.</p>

</div>
</div>
<a id="af9c22d0774145829eab7f508af1c8268" name="af9c22d0774145829eab7f508af1c8268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c22d0774145829eab7f508af1c8268">&#9670;&#160;</a></span>pcilib_lock_get_refs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcilib_lock_get_refs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <em>approximate</em> number of lock references as the crashed applications will may not unref. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>- pointer to initialized lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of lock refs </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  120</span>                                                 {</div>
<div class="line"><span class="lineno">  121</span>    <span class="keywordflow">return</span> lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>;</div>
<div class="line"><span class="lineno">  122</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">pcilib_lock_s::refs</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>.</p>

</div>
</div>
<a id="a458f1a70f478cb82cbb5d5586d130bd8" name="a458f1a70f478cb82cbb5d5586d130bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458f1a70f478cb82cbb5d5586d130bd8">&#9670;&#160;</a></span>pcilib_lock_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_lock_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment reference count(number of processes that may access the given lock). </p>
<p >Not thread/process safe unless system supports stdatomic (gcc 4.9+). In this case, the access should be synchronized by the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>- pointer to initialized lock </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   95</span>                                          {</div>
<div class="line"><span class="lineno">   96</span>    assert(lock);</div>
<div class="line"><span class="lineno">   97</span>    </div>
<div class="line"><span class="lineno">   98</span><span class="preprocessor">#ifdef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">   99</span>    atomic_fetch_add_explicit(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>, 1, memory_order_relaxed);</div>
<div class="line"><span class="lineno">  100</span><span class="preprocessor">#else </span><span class="comment">/* HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  101</span>    lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>++;</div>
<div class="line"><span class="lineno">  102</span><span class="preprocessor">#endif  </span><span class="comment">/* HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  103</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">pcilib_lock_s::refs</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>.</p>

</div>
</div>
<a id="aa610ccde435fcf312a7ad21288179966" name="aa610ccde435fcf312a7ad21288179966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610ccde435fcf312a7ad21288179966">&#9670;&#160;</a></span>pcilib_lock_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_lock_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement reference count (number of processes that may access the given lock) Not thread/process safe unless system supports stdatomic (gcc 4.9+). </p>
<p >In this case, the access should be synchronized by the caller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>- pointer to initialized lock </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  105</span>                                            {</div>
<div class="line"><span class="lineno">  106</span>    assert(lock);</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>    <span class="keywordflow">if</span> (!lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>) {</div>
<div class="line"><span class="lineno">  109</span>        <a class="code hl_define" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>(<span class="stringliteral">&quot;Lock is not referenced&quot;</span>);</div>
<div class="line"><span class="lineno">  110</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  111</span>    }</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span><span class="preprocessor">#ifdef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">  114</span>    atomic_fetch_sub_explicit(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>, 1, memory_order_relaxed);</div>
<div class="line"><span class="lineno">  115</span><span class="preprocessor">#else </span><span class="comment">/* HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  116</span>    lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">refs</a>--;</div>
<div class="line"><span class="lineno">  117</span><span class="preprocessor">#endif  </span><span class="comment">/* HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  118</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>, and <a class="el" href="structpcilib__lock__s.html#abc308dc2d6d2ca8c36ff851ee4d316b3">pcilib_lock_s::refs</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock()</a>.</p>

</div>
</div>
<a id="aede6140571a9d717300d31e0fd8079ee" name="aede6140571a9d717300d31e0fd8079ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede6140571a9d717300d31e0fd8079ee">&#9670;&#160;</a></span>pcilib_try_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_try_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function will try to take a lock for the mutex pointed by lockfunction to acquire a lock, but that returns immediatly if the lock can't be acquired on first try </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- the pointer to the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or 0 for correctness </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  193</span>                                         {</div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="lock_8c.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom</a>(lock, <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, <a class="code hl_define" href="pcilib_8h.html#a166dd3b3c2d265ec0c88cf5ed001b511">PCILIB_TIMEOUT_IMMEDIATE</a>);</div>
<div class="line"><span class="lineno">  195</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="lock_8c.html#a14bb35dfe3a00a051c7cd5ddb91b0b1b">pcilib_lock_custom()</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, and <a class="el" href="pcilib_8h.html#a166dd3b3c2d265ec0c88cf5ed001b511">PCILIB_TIMEOUT_IMMEDIATE</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__public__api__dma.html#gad6ad21e27311c68f05a5189ce628f9bf">pcilib_push_dma()</a>, and <a class="el" href="group__public__api__dma.html#ga500ad5dc629d20579e83f0df44162bb6">pcilib_stream_dma()</a>.</p>

</div>
</div>
<a id="a770c0ece9679b9b2589bd773b8cfb70e" name="a770c0ece9679b9b2589bd773b8cfb70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770c0ece9679b9b2589bd773b8cfb70e">&#9670;&#160;</a></span>pcilib_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function unlocks the lock pointed by lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- the integer that points to the semaphore </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  197</span>                                        {</div>
<div class="line"><span class="lineno">  198</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">if</span> (!lock)</div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">if</span> ((err = pthread_mutex_unlock(&amp;lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">mutex</a>)) != 0) {</div>
<div class="line"><span class="lineno">  204</span>        <span class="keywordflow">switch</span> (err) {</div>
<div class="line"><span class="lineno">  205</span>         <span class="keywordflow">case</span> EPERM:</div>
<div class="line"><span class="lineno">  206</span>            <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Trying to unlock not locked mutex (%s) or the mutex which was locked by a different thread&quot;</span>, lock-&gt;<a class="code hl_variable" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">name</a>);</div>
<div class="line"><span class="lineno">  207</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  208</span>         <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  209</span>            <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t unlock mutex, errno %i&quot;</span>, err);</div>
<div class="line"><span class="lineno">  210</span>        }</div>
<div class="line"><span class="lineno">  211</span>    }</div>
<div class="line"><span class="lineno">  212</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__lock__s.html#afd46dde3b2597ff411af6769c38c0a07">pcilib_lock_s::mutex</a>, <a class="el" href="structpcilib__lock__s.html#a1348e822fe29d2958cb5d74d79b064e9">pcilib_lock_s::name</a>, and <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>, <a class="el" href="group__public__api__dma.html#gad6ad21e27311c68f05a5189ce628f9bf">pcilib_push_dma()</a>, <a class="el" href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock()</a>, and <a class="el" href="group__public__api__dma.html#ga500ad5dc629d20579e83f0df44162bb6">pcilib_stream_dma()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 18 2024 22:02:48 for pcilib by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
