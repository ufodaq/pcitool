<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pcilib: locking.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">pcilib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0b5c8f32f3013e7b96dc99509907414c.html">pcilib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">locking.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>this file is the header file for functions that touch all locks allocated for software registers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="kmem_8h_source.html">pcilib/kmem.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="lock_8h_source.html">pcilib/lock.h</a>&gt;</code><br />
</div>
<p><a href="locking_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcilib__locking__s.html">pcilib_locking_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure defining the kernel space used for locks  <a href="structpcilib__locking__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae39798584a67ac2e81222dd2f029cd0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ae39798584a67ac2e81222dd2f029cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of maximum locks  <a href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">More...</a><br /></td></tr>
<tr class="separator:ae39798584a67ac2e81222dd2f029cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c0175954f5db671289658acba57cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#ab3c0175954f5db671289658acba57cda">PCILIB_LOCKS_PER_PAGE</a>&#160;&#160;&#160;(<a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>/<a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>)</td></tr>
<tr class="memdesc:ab3c0175954f5db671289658acba57cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of locks per page of kernel memory  <a href="locking_8h.html#ab3c0175954f5db671289658acba57cda">More...</a><br /></td></tr>
<tr class="separator:ab3c0175954f5db671289658acba57cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67e5643c6c886ea8c635016efb82af1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>&#160;&#160;&#160;((<a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a> * <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>)/<a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>)</td></tr>
<tr class="memdesc:ac67e5643c6c886ea8c635016efb82af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pages allocated for locks in kernel memory  <a href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">More...</a><br /></td></tr>
<tr class="separator:ac67e5643c6c886ea8c635016efb82af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a84bae4cf290e3d26cbd8d7f954350e04"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a></td></tr>
<tr class="memdesc:a84bae4cf290e3d26cbd8d7f954350e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">type to represent the index of a lock in the table of locks in the kernel space  <a href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">More...</a><br /></td></tr>
<tr class="separator:a84bae4cf290e3d26cbd8d7f954350e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad399c61eedd6d29dcd83bb61cd648b4d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpcilib__locking__s.html">pcilib_locking_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#ad399c61eedd6d29dcd83bb61cd648b4d">pcilib_locking_t</a></td></tr>
<tr class="separator:ad399c61eedd6d29dcd83bb61cd648b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af688eeaa5170de223b3af7e4e7c211e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#af688eeaa5170de223b3af7e4e7c211e0">pcilib_init_locking</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx)</td></tr>
<tr class="memdesc:af688eeaa5170de223b3af7e4e7c211e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the kernel space for the locks : if this space have been already initialized, then the previous space is returned.  <a href="locking_8h.html#af688eeaa5170de223b3af7e4e7c211e0">More...</a><br /></td></tr>
<tr class="separator:af688eeaa5170de223b3af7e4e7c211e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc8f6c273bcc2fffce974f686dffee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx)</td></tr>
<tr class="memdesc:a0cc8f6c273bcc2fffce974f686dffee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function cleans the memory from all locks : the kernel space is freed, and locks references in pcilib_t are destroyed by setting memory to 0  <a href="locking_8h.html#a0cc8f6c273bcc2fffce974f686dffee0">More...</a><br /></td></tr>
<tr class="separator:a0cc8f6c273bcc2fffce974f686dffee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf250829f88c240473e38fc0224ed5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx)</td></tr>
<tr class="memdesc:adbf250829f88c240473e38fc0224ed5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function use flock locking mechanism on the ALPS platform device file, to make sure to not create two kernel spaces for locks  <a href="locking_8h.html#adbf250829f88c240473e38fc0224ed5f">More...</a><br /></td></tr>
<tr class="separator:adbf250829f88c240473e38fc0224ed5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7b665a4a015a315d06c5314dc6e1eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx)</td></tr>
<tr class="memdesc:aee7b665a4a015a315d06c5314dc6e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to remove the lock created by flock on the ALPS platform device file  <a href="locking_8h.html#aee7b665a4a015a315d06c5314dc6e1eb">More...</a><br /></td></tr>
<tr class="separator:aee7b665a4a015a315d06c5314dc6e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa761ea9d8c20584689cd2659ba4429f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx, <a class="el" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a> id)</td></tr>
<tr class="memdesc:aa761ea9d8c20584689cd2659ba4429f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function returns the lock at the index in the kernel space equal to id  <a href="locking_8h.html#aa761ea9d8c20584689cd2659ba4429f9">More...</a><br /></td></tr>
<tr class="separator:aa761ea9d8c20584689cd2659ba4429f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108114a060800e54298643cb744f34d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> flags, const char *lock_id,...)</td></tr>
<tr class="memdesc:a108114a060800e54298643cb744f34d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function verify if the lock requested exists in the kernel space.  <a href="locking_8h.html#a108114a060800e54298643cb744f34d4">More...</a><br /></td></tr>
<tr class="separator:a108114a060800e54298643cb744f34d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74086b52f341fbc7807824a6bacf5e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a> flags, <a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *lock)</td></tr>
<tr class="memdesc:aa74086b52f341fbc7807824a6bacf5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is to decrement the variable in a lock containing the number of processes that may access to this lock(refs)  <a href="locking_8h.html#aa74086b52f341fbc7807824a6bacf5e7">More...</a><br /></td></tr>
<tr class="separator:aa74086b52f341fbc7807824a6bacf5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac379ebe1382f4517496a6da8ca2b0839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="locking_8h.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks</a> (<a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *ctx, int force)</td></tr>
<tr class="memdesc:ac379ebe1382f4517496a6da8ca2b0839"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function destroy all the locks that have been created(unref the locks + set memory to 0), and so is used when we want to clean properly the kernel space.  <a href="locking_8h.html#ac379ebe1382f4517496a6da8ca2b0839">More...</a><br /></td></tr>
<tr class="separator:ac379ebe1382f4517496a6da8ca2b0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >this file is the header file for functions that touch all locks allocated for software registers. </p>
<p >for more details about implementation choice, please read the file <a class="el" href="lock_8h.html" title="this file is the header file for the functions that implement a semaphore API for the pcitool program...">lock.h</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac67e5643c6c886ea8c635016efb82af1" name="ac67e5643c6c886ea8c635016efb82af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67e5643c6c886ea8c635016efb82af1">&#9670;&#160;</a></span>PCILIB_LOCK_PAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCILIB_LOCK_PAGES&#160;&#160;&#160;((<a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a> * <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>)/<a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of pages allocated for locks in kernel memory </p>

</div>
</div>
<a id="ab3c0175954f5db671289658acba57cda" name="ab3c0175954f5db671289658acba57cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c0175954f5db671289658acba57cda">&#9670;&#160;</a></span>PCILIB_LOCKS_PER_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCILIB_LOCKS_PER_PAGE&#160;&#160;&#160;(<a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>/<a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of locks per page of kernel memory </p>

</div>
</div>
<a id="ae39798584a67ac2e81222dd2f029cd0d" name="ae39798584a67ac2e81222dd2f029cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39798584a67ac2e81222dd2f029cd0d">&#9670;&#160;</a></span>PCILIB_MAX_LOCKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCILIB_MAX_LOCKS&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of maximum locks </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a84bae4cf290e3d26cbd8d7f954350e04" name="a84bae4cf290e3d26cbd8d7f954350e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bae4cf290e3d26cbd8d7f954350e04">&#9670;&#160;</a></span>pcilib_lock_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type to represent the index of a lock in the table of locks in the kernel space </p>

</div>
</div>
<a id="ad399c61eedd6d29dcd83bb61cd648b4d" name="ad399c61eedd6d29dcd83bb61cd648b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399c61eedd6d29dcd83bb61cd648b4d">&#9670;&#160;</a></span>pcilib_locking_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpcilib__locking__s.html">pcilib_locking_s</a> <a class="el" href="locking_8h.html#ad399c61eedd6d29dcd83bb61cd648b4d">pcilib_locking_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac379ebe1382f4517496a6da8ca2b0839" name="ac379ebe1382f4517496a6da8ca2b0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac379ebe1382f4517496a6da8ca2b0839">&#9670;&#160;</a></span>pcilib_destroy_all_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_destroy_all_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function destroy all the locks that have been created(unref the locks + set memory to 0), and so is used when we want to clean properly the kernel space. </p>
<p >If force is set to 1, then we don't care about other processes that may request locks. If not, if there is locks that may be requested by other processes, then the operation is stopped. Of course, destroying locks that may be requested by other processes results in an undefined behaviour. Thus, it is user responsibility to issue this command with force set to 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>- should the operation be forced or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code : 0 if everything was ok </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  244</span>                                                       {</div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">  246</span>    <a class="code hl_typedef" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a> i;</div>
<div class="line"><span class="lineno">  247</span>    <a class="code hl_enumeration" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48">pcilib_kmem_reuse_state_t</a> reused;</div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span>    <span class="keywordflow">if</span> (strcasecmp(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a124451df7bcbe85a2d9b7e8cb19814f9">model</a>, <span class="stringliteral">&quot;maintenance&quot;</span>)) {</div>
<div class="line"><span class="lineno">  250</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t destroy locks while locking subsystem is initialized, use maintenance model&quot;</span>);</div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a>;</div>
<div class="line"><span class="lineno">  252</span>    }</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>    err = <a class="code hl_function" href="locking_8c.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">if</span> (err) <span class="keywordflow">return</span> err;</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span>        <span class="comment">// ToDo: We should check here that no other instances of pcitool are running, the driver can provide this information</span></div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a> = <a class="code hl_function" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory</a>(ctx, <a class="code hl_enumvalue" href="kmem_8h.html#a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331">PCILIB_KMEM_TYPE_PAGE</a>, <a class="code hl_define" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>, <a class="code hl_define" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>, 0, <a class="code hl_define" href="kmem_8h.html#a1f5a834e88f100dc458108c49b0b475c">PCILIB_KMEM_USE</a>(<a class="code hl_enumvalue" href="kmem_8h.html#a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7">PCILIB_KMEM_USE_LOCKS</a>,0), <a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>|<a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a>);</div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">if</span> (!ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>) {</div>
<div class="line"><span class="lineno">  261</span>        <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  262</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Failed to allocate kernel memory of locking subsystem&quot;</span>);</div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">  264</span>    }</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>    reused = <a class="code hl_function" href="kmem_8c.html#ac2a3c0d541ee9e45f53ea48904fac65d">pcilib_kmem_is_reused</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>);</div>
<div class="line"><span class="lineno">  267</span>    <span class="keywordflow">if</span> (reused &amp; <a class="code hl_enumvalue" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964">PCILIB_KMEM_REUSE_PARTIAL</a>) {</div>
<div class="line"><span class="lineno">  268</span>        <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  269</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Inconsistent kernel memory for locking subsystem is found (only part of the required buffers is available)&quot;</span>);</div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a>;</div>
<div class="line"><span class="lineno">  271</span>    }</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">if</span> ((reused &amp; <a class="code hl_enumvalue" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d">PCILIB_KMEM_REUSE_REUSED</a>) == 0) {</div>
<div class="line"><span class="lineno">  274</span>        <a class="code hl_function" href="kmem_8c.html#a77eed4dcaa5a719b767ed275c332148e">pcilib_free_kernel_memory</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>, <a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>|<a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a>);</div>
<div class="line"><span class="lineno">  275</span>        <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  277</span>    }</div>
<div class="line"><span class="lineno">  278</span> </div>
<div class="line"><span class="lineno">  279</span>        <span class="comment">/* if we run in non-forced case, then if it may be still processes that can have access to the locks, they are not destroyed*/</span></div>
<div class="line"><span class="lineno">  280</span>    <span class="keywordflow">if</span> (!force) {</div>
<div class="line"><span class="lineno">  281</span>        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>; i++) {</div>
<div class="line"><span class="lineno">  282</span>            <a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_t</a> *lock = <a class="code hl_function" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a>(ctx, i);</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>            <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a>(lock);</div>
<div class="line"><span class="lineno">  285</span>            <span class="keywordflow">if</span> (!name) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  286</span>        </div>
<div class="line"><span class="lineno">  287</span>            <span class="keywordtype">size_t</span> refs = <a class="code hl_function" href="lock_8c.html#af9c22d0774145829eab7f508af1c8268">pcilib_lock_get_refs</a>(lock);</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>            <span class="keywordflow">if</span> (refs &gt; 0) {</div>
<div class="line"><span class="lineno">  290</span>                <span class="keywordtype">char</span> *stmp = strdup(name);</div>
<div class="line"><span class="lineno">  291</span>                <a class="code hl_function" href="locking_8c.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking</a>(ctx);</div>
<div class="line"><span class="lineno">  292</span>                <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  293</span>                <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Lock (%s) has %zu references, destroying references may result in crashes and data corruption&quot;</span>, stmp, refs);</div>
<div class="line"><span class="lineno">  294</span>                free(stmp);</div>
<div class="line"><span class="lineno">  295</span>                <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60cae16e1bf6797a9883778d310ed58d15f4">PCILIB_ERROR_BUSY</a>;</div>
<div class="line"><span class="lineno">  296</span>            }</div>
<div class="line"><span class="lineno">  297</span>        }</div>
<div class="line"><span class="lineno">  298</span>    }</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span>        <span class="comment">// Do we really need this? I guess zeroing should be enough</span></div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>; i++) {</div>
<div class="line"><span class="lineno">  302</span>        <a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_t</a> *lock = <a class="code hl_function" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a>(ctx, i);</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a>(lock);</div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">if</span> (!name) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  306</span> </div>
<div class="line"><span class="lineno">  307</span>        <a class="code hl_function" href="lock_8c.html#a9f35d68c341f974de509836821b72e24">pcilib_free_lock</a>(lock);</div>
<div class="line"><span class="lineno">  308</span>    }</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code hl_define" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>; i++) {</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordtype">void</span> *addr = (<span class="keywordtype">void</span>*)<a class="code hl_function" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>, i);</div>
<div class="line"><span class="lineno">  312</span>        memset(addr, 0, <a class="code hl_define" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>);</div>
<div class="line"><span class="lineno">  313</span>    }</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <a class="code hl_function" href="locking_8c.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking</a>(ctx);</div>
<div class="line"><span class="lineno">  316</span>    <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  319</span>}</div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a></div><div class="ttdeci">@ PCILIB_ERROR_FAILED</div><div class="ttdef"><b>Definition:</b> error.h:22</div></div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60cae16e1bf6797a9883778d310ed58d15f4"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60cae16e1bf6797a9883778d310ed58d15f4">PCILIB_ERROR_BUSY</a></div><div class="ttdeci">@ PCILIB_ERROR_BUSY</div><div class="ttdef"><b>Definition:</b> error.h:32</div></div>
<div class="ttc" id="aerror_8h_html_a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240"><div class="ttname"><a href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a></div><div class="ttdeci">@ PCILIB_ERROR_INVALID_STATE</div><div class="ttdef"><b>Definition:</b> error.h:19</div></div>
<div class="ttc" id="aerror_8h_html_a2b06064fecffd095efabb752f7b50021"><div class="ttname"><a href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a></div><div class="ttdeci">#define pcilib_error(...)</div><div class="ttdef"><b>Definition:</b> error.h:68</div></div>
<div class="ttc" id="akmem_8c_html_a77eed4dcaa5a719b767ed275c332148e"><div class="ttname"><a href="kmem_8c.html#a77eed4dcaa5a719b767ed275c332148e">pcilib_free_kernel_memory</a></div><div class="ttdeci">void pcilib_free_kernel_memory(pcilib_t *ctx, pcilib_kmem_handle_t *k, pcilib_kmem_flags_t flags)</div><div class="ttdoc">This function either frees the allocated kernel memory or just releases some of the references.</div><div class="ttdef"><b>Definition:</b> kmem.c:297</div></div>
<div class="ttc" id="akmem_8c_html_ac2a3c0d541ee9e45f53ea48904fac65d"><div class="ttname"><a href="kmem_8c.html#ac2a3c0d541ee9e45f53ea48904fac65d">pcilib_kmem_is_reused</a></div><div class="ttdeci">pcilib_kmem_reuse_state_t pcilib_kmem_is_reused(pcilib_t *ctx, pcilib_kmem_handle_t *k)</div><div class="ttdoc">Reports if the kernel memory was reused fully, partially, or allocated completely anew.</div><div class="ttdef"><b>Definition:</b> kmem.c:407</div></div>
<div class="ttc" id="akmem_8c_html_ac6559934a4616cbb9125caf2c1f8908e"><div class="ttname"><a href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory</a></div><div class="ttdeci">pcilib_kmem_handle_t * pcilib_alloc_kernel_memory(pcilib_t *ctx, pcilib_kmem_type_t type, size_t nmemb, size_t size, size_t alignment, pcilib_kmem_use_t use, pcilib_kmem_flags_t flags)</div><div class="ttdoc">This function either allocates new buffers in the kernel space or just re-uses existing buffers.</div><div class="ttdef"><b>Definition:</b> kmem.c:61</div></div>
<div class="ttc" id="akmem_8c_html_aee9f4941b33c0ae87675bffd02a48664"><div class="ttname"><a href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua</a></div><div class="ttdeci">volatile void * pcilib_kmem_get_block_ua(pcilib_t *ctx, pcilib_kmem_handle_t *k, size_t block)</div><div class="ttdoc">Get a valid pointer on the user-space mapping of the specified kernel memory buffer.</div><div class="ttdef"><b>Definition:</b> kmem.c:383</div></div>
<div class="ttc" id="akmem_8h_html_a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331"><div class="ttname"><a href="kmem_8h.html#a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331">PCILIB_KMEM_TYPE_PAGE</a></div><div class="ttdeci">@ PCILIB_KMEM_TYPE_PAGE</div><div class="ttdoc">A number of physically consequitive pages of memory.</div><div class="ttdef"><b>Definition:</b> kmem.h:22</div></div>
<div class="ttc" id="akmem_8h_html_a1f5a834e88f100dc458108c49b0b475c"><div class="ttname"><a href="kmem_8h.html#a1f5a834e88f100dc458108c49b0b475c">PCILIB_KMEM_USE</a></div><div class="ttdeci">#define PCILIB_KMEM_USE(type, subtype)</div><div class="ttdoc">Constructs full use from use type and use subtype.</div><div class="ttdef"><b>Definition:</b> kmem.h:18</div></div>
<div class="ttc" id="akmem_8h_html_a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7"><div class="ttname"><a href="kmem_8h.html#a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7">PCILIB_KMEM_USE_LOCKS</a></div><div class="ttdeci">@ PCILIB_KMEM_USE_LOCKS</div><div class="ttdoc">The kmem used to hold locks, the sub type is not used.</div><div class="ttdef"><b>Definition:</b> kmem.h:35</div></div>
<div class="ttc" id="akmem_8h_html_ab6f8d4f2207b8983bc511ca80c000110"><div class="ttname"><a href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a></div><div class="ttdeci">#define PCILIB_KMEM_PAGE_SIZE</div><div class="ttdoc">Default pages size is 4096 bytes.</div><div class="ttdef"><b>Definition:</b> kmem.h:7</div></div>
<div class="ttc" id="akmem_8h_html_ad9593c5ba7752ae78acd1e3164d38d48"><div class="ttname"><a href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48">pcilib_kmem_reuse_state_t</a></div><div class="ttdeci">pcilib_kmem_reuse_state_t</div><div class="ttdef"><b>Definition:</b> kmem.h:56</div></div>
<div class="ttc" id="akmem_8h_html_ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d"><div class="ttname"><a href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d">PCILIB_KMEM_REUSE_REUSED</a></div><div class="ttdeci">@ PCILIB_KMEM_REUSE_REUSED</div><div class="ttdoc">Already allocated kernel memory was re-used.</div><div class="ttdef"><b>Definition:</b> kmem.h:58</div></div>
<div class="ttc" id="akmem_8h_html_ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964"><div class="ttname"><a href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964">PCILIB_KMEM_REUSE_PARTIAL</a></div><div class="ttdeci">@ PCILIB_KMEM_REUSE_PARTIAL</div><div class="ttdoc">The kernel memory was partially re-used and partially allocated.</div><div class="ttdef"><b>Definition:</b> kmem.h:59</div></div>
<div class="ttc" id="akmem_8h_html_ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf"><div class="ttname"><a href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a></div><div class="ttdeci">@ PCILIB_KMEM_FLAG_REUSE</div><div class="ttdoc">Try to reuse existing buffer with the same use &amp; item.</div><div class="ttdef"><b>Definition:</b> kmem.h:46</div></div>
<div class="ttc" id="akmem_8h_html_ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6"><div class="ttname"><a href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a></div><div class="ttdeci">@ PCILIB_KMEM_FLAG_PERSISTENT</div><div class="ttdoc">Sets persistent mode.</div><div class="ttdef"><b>Definition:</b> kmem.h:48</div></div>
<div class="ttc" id="alock_8c_html_a9f35d68c341f974de509836821b72e24"><div class="ttname"><a href="lock_8c.html#a9f35d68c341f974de509836821b72e24">pcilib_free_lock</a></div><div class="ttdeci">void pcilib_free_lock(pcilib_lock_t *lock)</div><div class="ttdoc">this function will unref the defined lock.</div><div class="ttdef"><b>Definition:</b> lock.c:82</div></div>
<div class="ttc" id="alock_8c_html_aab2d31635f64d5b83e3a811dc1b2ddee"><div class="ttname"><a href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a></div><div class="ttdeci">const char * pcilib_lock_get_name(pcilib_lock_t *lock)</div><div class="ttdoc">this function gives the identifier name associated to a lock in the kernel space</div><div class="ttdef"><b>Definition:</b> lock.c:128</div></div>
<div class="ttc" id="alock_8c_html_af9c22d0774145829eab7f508af1c8268"><div class="ttname"><a href="lock_8c.html#af9c22d0774145829eab7f508af1c8268">pcilib_lock_get_refs</a></div><div class="ttdeci">size_t pcilib_lock_get_refs(pcilib_lock_t *lock)</div><div class="ttdoc">Return approximate number of lock references as the crashed applications will may not unref.</div><div class="ttdef"><b>Definition:</b> lock.c:120</div></div>
<div class="ttc" id="alocking_8c_html_a0cc8f6c273bcc2fffce974f686dffee0"><div class="ttname"><a href="locking_8c.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking</a></div><div class="ttdeci">void pcilib_free_locking(pcilib_t *ctx)</div><div class="ttdoc">this function cleans the memory from all locks : the kernel space is freed, and locks references in p...</div><div class="ttdef"><b>Definition:</b> locking.c:67</div></div>
<div class="ttc" id="alocking_8c_html_aa761ea9d8c20584689cd2659ba4429f9"><div class="ttname"><a href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a></div><div class="ttdeci">pcilib_lock_t * pcilib_get_lock_by_id(pcilib_t *ctx, pcilib_lock_id_t id)</div><div class="ttdoc">this function returns the lock at the index in the kernel space equal to id</div><div class="ttdef"><b>Definition:</b> locking.c:95</div></div>
<div class="ttc" id="alocking_8c_html_adbf250829f88c240473e38fc0224ed5f"><div class="ttname"><a href="locking_8c.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global</a></div><div class="ttdeci">int pcilib_lock_global(pcilib_t *ctx)</div><div class="ttdoc">this function use flock locking mechanism on the ALPS platform device file, to make sure to not creat...</div><div class="ttdef"><b>Definition:</b> locking.c:78</div></div>
<div class="ttc" id="alocking_8c_html_aee7b665a4a015a315d06c5314dc6e1eb"><div class="ttname"><a href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a></div><div class="ttdeci">void pcilib_unlock_global(pcilib_t *ctx)</div><div class="ttdoc">function to remove the lock created by flock on the ALPS platform device file</div><div class="ttdef"><b>Definition:</b> locking.c:90</div></div>
<div class="ttc" id="alocking_8h_html_a84bae4cf290e3d26cbd8d7f954350e04"><div class="ttname"><a href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a></div><div class="ttdeci">uint32_t pcilib_lock_id_t</div><div class="ttdoc">type to represent the index of a lock in the table of locks in the kernel space</div><div class="ttdef"><b>Definition:</b> locking.h:17</div></div>
<div class="ttc" id="alocking_8h_html_ac67e5643c6c886ea8c635016efb82af1"><div class="ttname"><a href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a></div><div class="ttdeci">#define PCILIB_LOCK_PAGES</div><div class="ttdoc">number of pages allocated for locks in kernel memory</div><div class="ttdef"><b>Definition:</b> locking.h:11</div></div>
<div class="ttc" id="alocking_8h_html_ae39798584a67ac2e81222dd2f029cd0d"><div class="ttname"><a href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a></div><div class="ttdeci">#define PCILIB_MAX_LOCKS</div><div class="ttdoc">number of maximum locks</div><div class="ttdef"><b>Definition:</b> locking.h:9</div></div>
<div class="ttc" id="astructpcilib__lock__s_html"><div class="ttname"><a href="structpcilib__lock__s.html">pcilib_lock_s</a></div><div class="ttdoc">structure to define a lock</div><div class="ttdef"><b>Definition:</b> lock.c:24</div></div>
<div class="ttc" id="astructpcilib__locking__s_html_a52775864cf84b5663e1e8c0f9b9738da"><div class="ttname"><a href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">pcilib_locking_s::kmem</a></div><div class="ttdeci">pcilib_kmem_handle_t * kmem</div><div class="ttdoc">kmem used to store mutexes</div><div class="ttdef"><b>Definition:</b> locking.h:25</div></div>
<div class="ttc" id="astructpcilib__s_html_a124451df7bcbe85a2d9b7e8cb19814f9"><div class="ttname"><a href="structpcilib__s.html#a124451df7bcbe85a2d9b7e8cb19814f9">pcilib_s::model</a></div><div class="ttdeci">char * model</div><div class="ttdoc">Requested model.</div><div class="ttdef"><b>Definition:</b> pci.h:71</div></div>
<div class="ttc" id="astructpcilib__s_html_a7f86351902a0aa153ac9019099f0e30f"><div class="ttname"><a href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a></div><div class="ttdeci">struct pcilib_locking_s locks</div><div class="ttdoc">Context of locking subsystem.</div><div class="ttdef"><b>Definition:</b> pci.h:104</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">pcilib_locking_s::kmem</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="structpcilib__s.html#a124451df7bcbe85a2d9b7e8cb19814f9">pcilib_s::model</a>, <a class="el" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory()</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60cae16e1bf6797a9883778d310ed58d15f4">PCILIB_ERROR_BUSY</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a>, <a class="el" href="kmem_8c.html#a77eed4dcaa5a719b767ed275c332148e">pcilib_free_kernel_memory()</a>, <a class="el" href="lock_8c.html#a9f35d68c341f974de509836821b72e24">pcilib_free_lock()</a>, <a class="el" href="locking_8c.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking()</a>, <a class="el" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id()</a>, <a class="el" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a>, <a class="el" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>, <a class="el" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua()</a>, <a class="el" href="kmem_8c.html#ac2a3c0d541ee9e45f53ea48904fac65d">pcilib_kmem_is_reused()</a>, <a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>, <a class="el" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964">PCILIB_KMEM_REUSE_PARTIAL</a>, <a class="el" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d">PCILIB_KMEM_REUSE_REUSED</a>, <a class="el" href="kmem_8h.html#a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331">PCILIB_KMEM_TYPE_PAGE</a>, <a class="el" href="kmem_8h.html#a1f5a834e88f100dc458108c49b0b475c">PCILIB_KMEM_USE</a>, <a class="el" href="kmem_8h.html#a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7">PCILIB_KMEM_USE_LOCKS</a>, <a class="el" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name()</a>, <a class="el" href="lock_8c.html#af9c22d0774145829eab7f508af1c8268">pcilib_lock_get_refs()</a>, <a class="el" href="locking_8c.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global()</a>, <a class="el" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>, <a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>, and <a class="el" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global()</a>.</p>

</div>
</div>
<a id="a0cc8f6c273bcc2fffce974f686dffee0" name="a0cc8f6c273bcc2fffce974f686dffee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc8f6c273bcc2fffce974f686dffee0">&#9670;&#160;</a></span>pcilib_free_locking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_free_locking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function cleans the memory from all locks : the kernel space is freed, and locks references in pcilib_t are destroyed by setting memory to 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   67</span>                                        {</div>
<div class="line"><span class="lineno">   68</span>    <span class="keywordflow">if</span> (ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>)</div>
<div class="line"><span class="lineno">   69</span>        <a class="code hl_function" href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock</a>(ctx, <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">   70</span> </div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> (ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>) {</div>
<div class="line"><span class="lineno">   72</span>        <a class="code hl_function" href="kmem_8c.html#a77eed4dcaa5a719b767ed275c332148e">pcilib_free_kernel_memory</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>, <a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>);</div>
<div class="line"><span class="lineno">   73</span>    }</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>    memset(&amp;ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>, 0, <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structpcilib__locking__s.html">pcilib_locking_t</a>));</div>
<div class="line"><span class="lineno">   76</span>}</div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAGS_DEFAULT</div><div class="ttdoc">Default flags.</div><div class="ttdef"><b>Definition:</b> lock.h:23</div></div>
<div class="ttc" id="alocking_8c_html_aa74086b52f341fbc7807824a6bacf5e7"><div class="ttname"><a href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock</a></div><div class="ttdeci">void pcilib_return_lock(pcilib_t *ctx, pcilib_lock_flags_t flags, pcilib_lock_t *lock)</div><div class="ttdoc">this function is to decrement the variable in a lock containing the number of processes that may acce...</div><div class="ttdef"><b>Definition:</b> locking.c:219</div></div>
<div class="ttc" id="astructpcilib__locking__s_html"><div class="ttname"><a href="structpcilib__locking__s.html">pcilib_locking_s</a></div><div class="ttdoc">structure defining the kernel space used for locks</div><div class="ttdef"><b>Definition:</b> locking.h:24</div></div>
<div class="ttc" id="astructpcilib__locking__s_html_a4cf6285bcd1e5af3ac3e68dc94038bf8"><div class="ttname"><a href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">pcilib_locking_s::locking</a></div><div class="ttdeci">pcilib_lock_t * locking</div><div class="ttdoc">lock used while intializing kernel space</div><div class="ttdef"><b>Definition:</b> locking.h:26</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">pcilib_locking_s::kmem</a>, <a class="el" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">pcilib_locking_s::locking</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="kmem_8c.html#a77eed4dcaa5a719b767ed275c332148e">pcilib_free_kernel_memory()</a>, <a class="el" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0adc99e7d1690b7856bc3459cdaa9a3ebe">PCILIB_LOCK_FLAGS_DEFAULT</a>, and <a class="el" href="locking_8c.html#aa74086b52f341fbc7807824a6bacf5e7">pcilib_return_lock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__public__api.html#ga809b61586ed9c56a7510c607859e75e3">pcilib_close()</a>, and <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>.</p>

</div>
</div>
<a id="a108114a060800e54298643cb744f34d4" name="a108114a060800e54298643cb744f34d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108114a060800e54298643cb744f34d4">&#9670;&#160;</a></span>pcilib_get_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> * pcilib_get_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function verify if the lock requested exists in the kernel space. </p>
<p >If yes, then nothing is done, else we create the lock in the kernel space. This function also gives the number of processes that may request the lock afterwards, including the one that just created it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- the flag defining the property of the lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_id</td><td>- the identifier name for the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding lock, or a new one if it did not exist before </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  104</span>                                                                                                    {</div>
<div class="line"><span class="lineno">  105</span>    <a class="code hl_typedef" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a> i;</div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordtype">int</span> err, ret;</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>    <a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_t</a> *lock;</div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordtype">char</span> buffer[<a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>];</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span>        <span class="comment">/* we construct the complete lock_id given the parameters of the function*/</span></div>
<div class="line"><span class="lineno">  112</span>    va_list pa;</div>
<div class="line"><span class="lineno">  113</span>    va_start(pa, lock_id);</div>
<div class="line"><span class="lineno">  114</span>    ret = vsnprintf(buffer, <a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>, lock_id, pa);</div>
<div class="line"><span class="lineno">  115</span>    va_end(pa);</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line"><span class="lineno">  118</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Failed to construct the lock id, probably arguments does not match the format string (%s)...&quot;</span>, lock_id);</div>
<div class="line"><span class="lineno">  119</span>        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  120</span>    }</div>
<div class="line"><span class="lineno">  121</span>        </div>
<div class="line"><span class="lineno">  122</span>        </div>
<div class="line"><span class="lineno">  123</span>        <span class="comment">/* we iterate through locks to see if there is one already with the same name*/</span> </div>
<div class="line"><span class="lineno">  124</span>        <span class="comment">// Would be nice to have hash here</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>; i++) {</div>
<div class="line"><span class="lineno">  126</span>        lock = <a class="code hl_function" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a>(ctx, i);</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a>(lock);</div>
<div class="line"><span class="lineno">  129</span>        <span class="keywordflow">if</span> (!name) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  130</span>        </div>
<div class="line"><span class="lineno">  131</span>        <span class="keywordflow">if</span> (!strcmp(buffer, name)) {</div>
<div class="line"><span class="lineno">  132</span>            <span class="keywordflow">if</span> ((<a class="code hl_function" href="lock_8c.html#a37ac119e9c186913d1cced9db262d784">pcilib_lock_get_flags</a>(lock)&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>) != (flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>)) {</div>
<div class="line"><span class="lineno">  133</span>                <span class="keywordflow">if</span> (flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>)</div>
<div class="line"><span class="lineno">  134</span>                    <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Requesting persistent lock (%s), but requested lock is already existing and is robust&quot;</span>, name);</div>
<div class="line"><span class="lineno">  135</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  136</span>                    <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Requesting robust lock (%s), but requested lock is already existing and is persistent&quot;</span>, name);</div>
<div class="line"><span class="lineno">  137</span>                <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  138</span>            }</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span><span class="preprocessor">#ifndef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">  141</span>            <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0) {</div>
<div class="line"><span class="lineno">  142</span>                err = <a class="code hl_function" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  143</span>                <span class="keywordflow">if</span> (err) {</div>
<div class="line"><span class="lineno">  144</span>                    <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Error (%i) obtaining global lock&quot;</span>, err);</div>
<div class="line"><span class="lineno">  145</span>                    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  146</span>                }</div>
<div class="line"><span class="lineno">  147</span>            }</div>
<div class="line"><span class="lineno">  148</span><span class="preprocessor">#endif </span><span class="comment">/* ! HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  149</span>        <span class="comment">/* if yes, we increment its ref variable*/</span></div>
<div class="line"><span class="lineno">  150</span>            <a class="code hl_function" href="lock_8c.html#a458f1a70f478cb82cbb5d5586d130bd8">pcilib_lock_ref</a>(lock);</div>
<div class="line"><span class="lineno">  151</span><span class="preprocessor">#ifndef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">  152</span>            <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  153</span>                <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  154</span><span class="preprocessor">#endif </span><span class="comment">/* ! HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>            <span class="keywordflow">return</span> lock;</div>
<div class="line"><span class="lineno">  157</span>        }</div>
<div class="line"><span class="lineno">  158</span>    }</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0) {</div>
<div class="line"><span class="lineno">  161</span>        err = <a class="code hl_function" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  162</span>        <span class="keywordflow">if</span> (err) {</div>
<div class="line"><span class="lineno">  163</span>            <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Error (%i) obtaining global lock&quot;</span>, err);</div>
<div class="line"><span class="lineno">  164</span>            <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  165</span>        }</div>
<div class="line"><span class="lineno">  166</span>    }</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>        <span class="comment">// Make sure it was not allocated meanwhile</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">for</span> (; i &lt; <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>; i++) {</div>
<div class="line"><span class="lineno">  170</span>        lock = <a class="code hl_function" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id</a>(ctx, i);</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name</a>(lock);</div>
<div class="line"><span class="lineno">  173</span>        <span class="keywordflow">if</span> (!name) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span>        <span class="keywordflow">if</span> (!strcmp(buffer, name)) {</div>
<div class="line"><span class="lineno">  176</span>            <span class="keywordflow">if</span> ((<a class="code hl_function" href="lock_8c.html#a37ac119e9c186913d1cced9db262d784">pcilib_lock_get_flags</a>(lock)&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>) != (flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>)) {</div>
<div class="line"><span class="lineno">  177</span>                <span class="keywordflow">if</span> (flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>)</div>
<div class="line"><span class="lineno">  178</span>                    <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Requesting persistent lock (%s), but requested lock is already existing and is robust&quot;</span>, name);</div>
<div class="line"><span class="lineno">  179</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  180</span>                    <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Requesting robust lock (%s), but requested lock is already existing and is persistent&quot;</span>, name);</div>
<div class="line"><span class="lineno">  181</span>                </div>
<div class="line"><span class="lineno">  182</span>                <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  183</span>                    <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  184</span>                <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  185</span>            }</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span>            <a class="code hl_function" href="lock_8c.html#a458f1a70f478cb82cbb5d5586d130bd8">pcilib_lock_ref</a>(lock);</div>
<div class="line"><span class="lineno">  188</span>            <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  189</span>                <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  190</span>            <span class="keywordflow">return</span> lock;</div>
<div class="line"><span class="lineno">  191</span>        }</div>
<div class="line"><span class="lineno">  192</span>    }</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">if</span> (i == <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>) {</div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  196</span>            <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  197</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Failed to create lock (%s), only %u locks is supported&quot;</span>, buffer, <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>);</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  199</span>    }</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>        <span class="comment">/* if the lock did not exist before, then we create it*/</span></div>
<div class="line"><span class="lineno">  202</span>    err = <a class="code hl_function" href="lock_8c.html#a51fc3ca69c4c13c92fea15a4693471c4">pcilib_init_lock</a>(lock, flags, buffer);</div>
<div class="line"><span class="lineno">  203</span>    </div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordflow">if</span> (err) {</div>
<div class="line"><span class="lineno">  205</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Lock initialization failed with error %i&quot;</span>, err);</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span>        <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  208</span>            <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  209</span>        </div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  211</span>    }</div>
<div class="line"><span class="lineno">  212</span>    </div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  214</span>        <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  215</span> </div>
<div class="line"><span class="lineno">  216</span>    <span class="keywordflow">return</span> lock;</div>
<div class="line"><span class="lineno">  217</span>}</div>
<div class="ttc" id="alock_8c_html_a37ac119e9c186913d1cced9db262d784"><div class="ttname"><a href="lock_8c.html#a37ac119e9c186913d1cced9db262d784">pcilib_lock_get_flags</a></div><div class="ttdeci">pcilib_lock_flags_t pcilib_lock_get_flags(pcilib_lock_t *lock)</div><div class="ttdoc">gets the flags associated to the given lock</div><div class="ttdef"><b>Definition:</b> lock.c:124</div></div>
<div class="ttc" id="alock_8c_html_a458f1a70f478cb82cbb5d5586d130bd8"><div class="ttname"><a href="lock_8c.html#a458f1a70f478cb82cbb5d5586d130bd8">pcilib_lock_ref</a></div><div class="ttdeci">void pcilib_lock_ref(pcilib_lock_t *lock)</div><div class="ttdoc">Increment reference count(number of processes that may access the given lock).</div><div class="ttdef"><b>Definition:</b> lock.c:95</div></div>
<div class="ttc" id="alock_8c_html_a51fc3ca69c4c13c92fea15a4693471c4"><div class="ttname"><a href="lock_8c.html#a51fc3ca69c4c13c92fea15a4693471c4">pcilib_init_lock</a></div><div class="ttdeci">int pcilib_init_lock(pcilib_lock_t *lock, pcilib_lock_flags_t flags, const char *lock_id)</div><div class="ttdoc">this function initializes a lock, by setting correctly its property given the flags associated.</div><div class="ttdef"><b>Definition:</b> lock.c:36</div></div>
<div class="ttc" id="alock_8c_html_a75727162630a3ad5cd76822f9f3e41a4"><div class="ttname"><a href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock</a></div><div class="ttdeci">int pcilib_lock(pcilib_lock_t *lock)</div><div class="ttdoc">function to acquire a lock, and wait till the lock can be acquire</div><div class="ttdef"><b>Definition:</b> lock.c:189</div></div>
<div class="ttc" id="alock_8c_html_a770c0ece9679b9b2589bd773b8cfb70e"><div class="ttname"><a href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a></div><div class="ttdeci">void pcilib_unlock(pcilib_lock_t *lock)</div><div class="ttdoc">this function unlocks the lock pointed by lock</div><div class="ttdef"><b>Definition:</b> lock.c:197</div></div>
<div class="ttc" id="alock_8h_html_a54d0a1249c3ee45d95ccbe09970b7aea"><div class="ttname"><a href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a></div><div class="ttdeci">#define PCILIB_LOCK_SIZE</div><div class="ttdoc">size of one lock.</div><div class="ttdef"><b>Definition:</b> lock.h:15</div></div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAG_UNLOCKED</div><div class="ttdoc">Perform operations unlocked, thus without taking care of the lock (protected by global flock during i...</div><div class="ttdef"><b>Definition:</b> lock.h:24</div></div>
<div class="ttc" id="alock_8h_html_aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9"><div class="ttname"><a href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a></div><div class="ttdeci">@ PCILIB_LOCK_FLAG_PERSISTENT</div><div class="ttdoc">Do not create robust mutexes, but preserve the lock across application launches.</div><div class="ttdef"><b>Definition:</b> lock.h:25</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">pcilib_locking_s::locking</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="locking_8c.html#aa761ea9d8c20584689cd2659ba4429f9">pcilib_get_lock_by_id()</a>, <a class="el" href="lock_8c.html#a51fc3ca69c4c13c92fea15a4693471c4">pcilib_init_lock()</a>, <a class="el" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock()</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0afd4208c72d7b8b947f37b2f272e57fd9">PCILIB_LOCK_FLAG_PERSISTENT</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>, <a class="el" href="lock_8c.html#a37ac119e9c186913d1cced9db262d784">pcilib_lock_get_flags()</a>, <a class="el" href="lock_8c.html#aab2d31635f64d5b83e3a811dc1b2ddee">pcilib_lock_get_name()</a>, <a class="el" href="lock_8c.html#a458f1a70f478cb82cbb5d5586d130bd8">pcilib_lock_ref()</a>, <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>, <a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>, and <a class="el" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dma_8c.html#a447eef48e9a6e4b8e2f61d6ce746c466">pcilib_init_dma()</a>, and <a class="el" href="locking_8c.html#af688eeaa5170de223b3af7e4e7c211e0">pcilib_init_locking()</a>.</p>

</div>
</div>
<a id="aa761ea9d8c20584689cd2659ba4429f9" name="aa761ea9d8c20584689cd2659ba4429f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa761ea9d8c20584689cd2659ba4429f9">&#9670;&#160;</a></span>pcilib_get_lock_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> * pcilib_get_lock_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="locking_8h.html#a84bae4cf290e3d26cbd8d7f954350e04">pcilib_lock_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function returns the lock at the index in the kernel space equal to id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>- the index of the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lock structure corresponding </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   95</span>                                                                         {</div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordtype">int</span> page = <span class="keywordtype">id</span> / <a class="code hl_define" href="locking_8h.html#ab3c0175954f5db671289658acba57cda">PCILIB_LOCKS_PER_PAGE</a>;</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordtype">int</span> offset = <span class="keywordtype">id</span> - page * <a class="code hl_define" href="locking_8h.html#ab3c0175954f5db671289658acba57cda">PCILIB_LOCKS_PER_PAGE</a>;</div>
<div class="line"><span class="lineno">   98</span>    <span class="keyword">volatile</span> <span class="keywordtype">void</span> *addr = <a class="code hl_function" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>, page);</div>
<div class="line"><span class="lineno">   99</span>    <a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_t</a> *lock = (<a class="code hl_struct" href="structpcilib__lock__s.html">pcilib_lock_t</a>*)(addr + offset * <a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>);</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>    <span class="keywordflow">return</span> lock;</div>
<div class="line"><span class="lineno">  102</span>}</div>
<div class="ttc" id="alocking_8h_html_ab3c0175954f5db671289658acba57cda"><div class="ttname"><a href="locking_8h.html#ab3c0175954f5db671289658acba57cda">PCILIB_LOCKS_PER_PAGE</a></div><div class="ttdeci">#define PCILIB_LOCKS_PER_PAGE</div><div class="ttdoc">number of locks per page of kernel memory</div><div class="ttdef"><b>Definition:</b> locking.h:10</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">pcilib_locking_s::kmem</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua()</a>, <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>, and <a class="el" href="locking_8h.html#ab3c0175954f5db671289658acba57cda">PCILIB_LOCKS_PER_PAGE</a>.</p>

<p class="reference">Referenced by <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>, and <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>.</p>

</div>
</div>
<a id="af688eeaa5170de223b3af7e4e7c211e0" name="af688eeaa5170de223b3af7e4e7c211e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af688eeaa5170de223b3af7e4e7c211e0">&#9670;&#160;</a></span>pcilib_init_locking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_init_locking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the kernel space for the locks : if this space have been already initialized, then the previous space is returned. </p>
<p >If not, the space is created. this function has to be protected, in order to avoid the simultaneous creation of 2 kernel spaces. For that, we use pcilib_lock_global. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running, getting filled with a ref to locks' kernel space </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   18</span>                                       {</div>
<div class="line"><span class="lineno">   19</span>    <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="lineno">   20</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">   21</span>    <a class="code hl_enumeration" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48">pcilib_kmem_reuse_state_t</a> reused;</div>
<div class="line"><span class="lineno">   22</span> </div>
<div class="line"><span class="lineno">   23</span>    assert(<a class="code hl_define" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a> * <a class="code hl_define" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a> &gt;= <a class="code hl_define" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a> * <a class="code hl_define" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>);</div>
<div class="line"><span class="lineno">   24</span>        </div>
<div class="line"><span class="lineno">   25</span>        <span class="comment">/*protection against multiple creations of kernel space*/</span></div>
<div class="line"><span class="lineno">   26</span>    err = <a class="code hl_function" href="locking_8c.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global</a>(ctx);</div>
<div class="line"><span class="lineno">   27</span>    <span class="keywordflow">if</span> (err) <span class="keywordflow">return</span> err;</div>
<div class="line"><span class="lineno">   28</span> </div>
<div class="line"><span class="lineno">   29</span>        <span class="comment">/* by default, this kernel space is persistent and will be reused, in order to avoid the big initialization times for robust mutexes each time we run pcitool*/</span></div>
<div class="line"><span class="lineno">   30</span>    ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a> = <a class="code hl_function" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory</a>(ctx, <a class="code hl_enumvalue" href="kmem_8h.html#a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331">PCILIB_KMEM_TYPE_PAGE</a>, <a class="code hl_define" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>, <a class="code hl_define" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>, 0, <a class="code hl_define" href="kmem_8h.html#a1f5a834e88f100dc458108c49b0b475c">PCILIB_KMEM_USE</a>(<a class="code hl_enumvalue" href="kmem_8h.html#a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7">PCILIB_KMEM_USE_LOCKS</a>,0), <a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>|<a class="code hl_enumvalue" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a>);</div>
<div class="line"><span class="lineno">   31</span>    <span class="keywordflow">if</span> (!ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>) {</div>
<div class="line"><span class="lineno">   32</span>        <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">   33</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Allocation of kernel memory for locking subsystem has failed&quot;</span>);</div>
<div class="line"><span class="lineno">   34</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   35</span>    }</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span>    reused = <a class="code hl_function" href="kmem_8c.html#ac2a3c0d541ee9e45f53ea48904fac65d">pcilib_kmem_is_reused</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>);</div>
<div class="line"><span class="lineno">   38</span>    <span class="keywordflow">if</span> (reused &amp; <a class="code hl_enumvalue" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964">PCILIB_KMEM_REUSE_PARTIAL</a>) {</div>
<div class="line"><span class="lineno">   39</span>        <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">   40</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Inconsistent kernel memory for locking subsystem is found (only part of the required buffers is available)&quot;</span>);</div>
<div class="line"><span class="lineno">   41</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a>;</div>
<div class="line"><span class="lineno">   42</span>    }</div>
<div class="line"><span class="lineno">   43</span> </div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">if</span> ((reused &amp; <a class="code hl_enumvalue" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d">PCILIB_KMEM_REUSE_REUSED</a>) == 0) {</div>
<div class="line"><span class="lineno">   45</span>        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code hl_define" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>; i++) {</div>
<div class="line"><span class="lineno">   46</span>            <span class="keywordtype">void</span> *addr = (<span class="keywordtype">void</span>*)<a class="code hl_function" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua</a>(ctx, ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">kmem</a>, i);</div>
<div class="line"><span class="lineno">   47</span>            memset(addr, 0, <a class="code hl_define" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>);</div>
<div class="line"><span class="lineno">   48</span>        }</div>
<div class="line"><span class="lineno">   49</span>    }</div>
<div class="line"><span class="lineno">   50</span> </div>
<div class="line"><span class="lineno">   51</span>        <span class="comment">/* the lock that has been used for the creation of kernel space is declared unlocked, has we shouldnot use it anymore*/</span></div>
<div class="line"><span class="lineno">   52</span>    ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a> = <a class="code hl_function" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock</a>(ctx, <a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>, <span class="stringliteral">&quot;locking&quot;</span>);</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>    <a class="code hl_function" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global</a>(ctx);</div>
<div class="line"><span class="lineno">   55</span> </div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">if</span> ((!ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>)) {</div>
<div class="line"><span class="lineno">   57</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Locking subsystem has failed to initialized mandatory global locks&quot;</span>);</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   59</span>    }</div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">   62</span>}</div>
<div class="ttc" id="alocking_8c_html_a108114a060800e54298643cb744f34d4"><div class="ttname"><a href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock</a></div><div class="ttdeci">pcilib_lock_t * pcilib_get_lock(pcilib_t *ctx, pcilib_lock_flags_t flags, const char *lock_id,...)</div><div class="ttdoc">this function verify if the lock requested exists in the kernel space.</div><div class="ttdef"><b>Definition:</b> locking.c:104</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a52775864cf84b5663e1e8c0f9b9738da">pcilib_locking_s::kmem</a>, <a class="el" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">pcilib_locking_s::locking</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory()</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>, <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60caed0e669166d0329e7d2c2b5dedf54240">PCILIB_ERROR_INVALID_STATE</a>, <a class="el" href="locking_8c.html#a108114a060800e54298643cb744f34d4">pcilib_get_lock()</a>, <a class="el" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda7cd91729fe864a6ae9f0192909f8cde6">PCILIB_KMEM_FLAG_PERSISTENT</a>, <a class="el" href="kmem_8h.html#ae91539a22992b31d5ecbe338ed230bcda074f7eaee0589d2d0eb90b9807f755cf">PCILIB_KMEM_FLAG_REUSE</a>, <a class="el" href="kmem_8c.html#aee9f4941b33c0ae87675bffd02a48664">pcilib_kmem_get_block_ua()</a>, <a class="el" href="kmem_8c.html#ac2a3c0d541ee9e45f53ea48904fac65d">pcilib_kmem_is_reused()</a>, <a class="el" href="kmem_8h.html#ab6f8d4f2207b8983bc511ca80c000110">PCILIB_KMEM_PAGE_SIZE</a>, <a class="el" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a8c3b52eba08a1a3c1b8cf255be084964">PCILIB_KMEM_REUSE_PARTIAL</a>, <a class="el" href="kmem_8h.html#ad9593c5ba7752ae78acd1e3164d38d48a208a355950eafd1ec15debad10265e6d">PCILIB_KMEM_REUSE_REUSED</a>, <a class="el" href="kmem_8h.html#a0026872c63f522459ae8510c9653ba66a83c7f4b602188c78ddf226498890d331">PCILIB_KMEM_TYPE_PAGE</a>, <a class="el" href="kmem_8h.html#a1f5a834e88f100dc458108c49b0b475c">PCILIB_KMEM_USE</a>, <a class="el" href="kmem_8h.html#a30160d6ee0113e9eb63b28f62f8bc485aba713c036118f491d984a4b754b4ddd7">PCILIB_KMEM_USE_LOCKS</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>, <a class="el" href="locking_8c.html#adbf250829f88c240473e38fc0224ed5f">pcilib_lock_global()</a>, <a class="el" href="locking_8h.html#ac67e5643c6c886ea8c635016efb82af1">PCILIB_LOCK_PAGES</a>, <a class="el" href="lock_8h.html#a54d0a1249c3ee45d95ccbe09970b7aea">PCILIB_LOCK_SIZE</a>, <a class="el" href="locking_8h.html#ae39798584a67ac2e81222dd2f029cd0d">PCILIB_MAX_LOCKS</a>, and <a class="el" href="locking_8c.html#aee7b665a4a015a315d06c5314dc6e1eb">pcilib_unlock_global()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__public__api.html#gaa6d33dcd1de77fa87c66276653c164a0">pcilib_open()</a>.</p>

</div>
</div>
<a id="adbf250829f88c240473e38fc0224ed5f" name="adbf250829f88c240473e38fc0224ed5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf250829f88c240473e38fc0224ed5f">&#9670;&#160;</a></span>pcilib_lock_global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcilib_lock_global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function use flock locking mechanism on the ALPS platform device file, to make sure to not create two kernel spaces for locks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   78</span>                                      {</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">   80</span>    </div>
<div class="line"><span class="lineno">   81</span>    <span class="comment">/* we flock() on the board&#39;s device file to make sure to not have two initialization in the same time (possible long time to init) */</span></div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">if</span> ((err = flock(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a97959ae9b1ab77309f0afec2b62d283c">handle</a>, LOCK_EX))==-1) {</div>
<div class="line"><span class="lineno">   83</span>        <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Can&#39;t get flock on device file&quot;</span>);</div>
<div class="line"><span class="lineno">   84</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>;</div>
<div class="line"><span class="lineno">   85</span>    }</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">   88</span>}</div>
<div class="ttc" id="astructpcilib__s_html_a97959ae9b1ab77309f0afec2b62d283c"><div class="ttname"><a href="structpcilib__s.html#a97959ae9b1ab77309f0afec2b62d283c">pcilib_s::handle</a></div><div class="ttdeci">int handle</div><div class="ttdoc">file handle of device</div><div class="ttdef"><b>Definition:</b> pci.h:48</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__s.html#a97959ae9b1ab77309f0afec2b62d283c">pcilib_s::handle</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, and <a class="el" href="error_8h.html#a0c59f7091fd2446121868635aca9e60ca8a1b45502224b7b2659e0014d9acf50c">PCILIB_ERROR_FAILED</a>.</p>

<p class="reference">Referenced by <a class="el" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory()</a>, <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>, <a class="el" href="locking_8c.html#af688eeaa5170de223b3af7e4e7c211e0">pcilib_init_locking()</a>, <a class="el" href="mem_8c.html#addcade89604fc01f2bc33f80f0f11485">pcilib_map_area()</a>, and <a class="el" href="bar_8c.html#a803f5e0c0ea90b723f268916c5410b23">pcilib_map_bar()</a>.</p>

</div>
</div>
<a id="aa74086b52f341fbc7807824a6bacf5e7" name="aa74086b52f341fbc7807824a6bacf5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74086b52f341fbc7807824a6bacf5e7">&#9670;&#160;</a></span>pcilib_return_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_return_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0">pcilib_lock_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock_8h.html#a657bc5577cf8315f3407e29505da135b">pcilib_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function is to decrement the variable in a lock containing the number of processes that may access to this lock(refs) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- the flag defining the property of the lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>- pointer to the lock we want to modify </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  219</span>                                                                                       {</div>
<div class="line"><span class="lineno">  220</span><span class="preprocessor">#ifndef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">  221</span>        <span class="keywordtype">int</span> err;</div>
<div class="line"><span class="lineno">  222</span>        </div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0) {</div>
<div class="line"><span class="lineno">  224</span>            err = <a class="code hl_function" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  225</span>            <span class="keywordflow">if</span> (err) {</div>
<div class="line"><span class="lineno">  226</span>                <a class="code hl_define" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>(<span class="stringliteral">&quot;Error (%i) obtaining global lock&quot;</span>, err);</div>
<div class="line"><span class="lineno">  227</span>                <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  228</span>            }</div>
<div class="line"><span class="lineno">  229</span>        }</div>
<div class="line"><span class="lineno">  230</span><span class="preprocessor">#endif </span><span class="comment">/* ! HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  231</span>        <a class="code hl_function" href="lock_8c.html#aa610ccde435fcf312a7ad21288179966">pcilib_lock_unref</a>(lock);</div>
<div class="line"><span class="lineno">  232</span><span class="preprocessor">#ifndef HAVE_STDATOMIC_H</span></div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">if</span> ((flags&amp;<a class="code hl_enumvalue" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>)==0)</div>
<div class="line"><span class="lineno">  234</span>            <a class="code hl_function" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock</a>(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">locks</a>.<a class="code hl_variable" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">locking</a>);</div>
<div class="line"><span class="lineno">  235</span><span class="preprocessor">#endif </span><span class="comment">/* ! HAVE_STDATOMIC_H */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno">  236</span>}</div>
<div class="ttc" id="alock_8c_html_aa610ccde435fcf312a7ad21288179966"><div class="ttname"><a href="lock_8c.html#aa610ccde435fcf312a7ad21288179966">pcilib_lock_unref</a></div><div class="ttdeci">void pcilib_lock_unref(pcilib_lock_t *lock)</div><div class="ttdoc">Decrement reference count (number of processes that may access the given lock) Not thread/process saf...</div><div class="ttdef"><b>Definition:</b> lock.c:105</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__locking__s.html#a4cf6285bcd1e5af3ac3e68dc94038bf8">pcilib_locking_s::locking</a>, <a class="el" href="structpcilib__s.html#a7f86351902a0aa153ac9019099f0e30f">pcilib_s::locks</a>, <a class="el" href="error_8h.html#a2b06064fecffd095efabb752f7b50021">pcilib_error</a>, <a class="el" href="lock_8c.html#a75727162630a3ad5cd76822f9f3e41a4">pcilib_lock()</a>, <a class="el" href="lock_8h.html#aac523db17d247c418fb56dbc279113d0a8cc0f02021b429b453c40888faf6f626">PCILIB_LOCK_FLAG_UNLOCKED</a>, <a class="el" href="lock_8c.html#aa610ccde435fcf312a7ad21288179966">pcilib_lock_unref()</a>, and <a class="el" href="lock_8c.html#a770c0ece9679b9b2589bd773b8cfb70e">pcilib_unlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__public__api.html#ga809b61586ed9c56a7510c607859e75e3">pcilib_close()</a>, and <a class="el" href="locking_8c.html#a0cc8f6c273bcc2fffce974f686dffee0">pcilib_free_locking()</a>.</p>

</div>
</div>
<a id="aee7b665a4a015a315d06c5314dc6e1eb" name="aee7b665a4a015a315d06c5314dc6e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7b665a4a015a315d06c5314dc6e1eb">&#9670;&#160;</a></span>pcilib_unlock_global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcilib_unlock_global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kmem_8h.html#a51f63ba035402ca9a2ddd1b11152d7f5">pcilib_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to remove the lock created by flock on the ALPS platform device file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>- the pcilib_t structure running </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   90</span>                                         {</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">if</span> (flock(ctx-&gt;<a class="code hl_variable" href="structpcilib__s.html#a97959ae9b1ab77309f0afec2b62d283c">handle</a>, LOCK_UN) == -1)</div>
<div class="line"><span class="lineno">   92</span>        <a class="code hl_define" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>(<span class="stringliteral">&quot;Could not correctly remove lock from the device file&quot;</span>);</div>
<div class="line"><span class="lineno">   93</span>}</div>
<div class="ttc" id="aerror_8h_html_a62fff84bc7941d1a39700b931716bbe9"><div class="ttname"><a href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a></div><div class="ttdeci">#define pcilib_warning(...)</div><div class="ttdef"><b>Definition:</b> error.h:69</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structpcilib__s.html#a97959ae9b1ab77309f0afec2b62d283c">pcilib_s::handle</a>, and <a class="el" href="error_8h.html#a62fff84bc7941d1a39700b931716bbe9">pcilib_warning</a>.</p>

<p class="reference">Referenced by <a class="el" href="kmem_8c.html#ac6559934a4616cbb9125caf2c1f8908e">pcilib_alloc_kernel_memory()</a>, <a class="el" href="locking_8c.html#ac379ebe1382f4517496a6da8ca2b0839">pcilib_destroy_all_locks()</a>, <a class="el" href="locking_8c.html#af688eeaa5170de223b3af7e4e7c211e0">pcilib_init_locking()</a>, <a class="el" href="mem_8c.html#addcade89604fc01f2bc33f80f0f11485">pcilib_map_area()</a>, and <a class="el" href="bar_8c.html#a803f5e0c0ea90b723f268916c5410b23">pcilib_map_bar()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 18 2024 22:02:48 for pcilib by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
